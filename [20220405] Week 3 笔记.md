# Week 3

## Lecture 1

这节课的主题是序列和数据抽象。

这节课首先讲述了 `List`，作为对象的容器。直到这节课才开始讲 `for` 语句（因为前面都没有引入的必要，有了列表我们需要 `for` 这个语法糖代替 `while` 和一些麻烦的绑定）。`for` 是对可迭代对象进行的操作，所以这节课也介绍了 `range` 以及它到 `list` 的转换。这节课还介绍了 `str`。

这节课用有理数这个数据结构的例子阐述了我们如何来做数据抽象：将数据的操作和表示分开。通过数据抽象，我们可以在程序之间建立起抽象屏障。好的程序设计者能够用好抽象屏障。最后，这节课用 lambda 实现序对，作为用列表实现的补充，来阐述抽象屏障的强大威力：我们更改了有理数的内部表示，但是使用它的代码却完全不需要任何修改，仍然能够正确运行。

## Lecture 2

这节课的主题是 Debugging，也就是如何排查代码中的错误，以及如何写出稳定的代码。这节课介绍了断言（assert）、各种测试（文档测试和单独的文件测试）、打印输出查错、和交互环境调试。这节课也讲述了错误类型、错误栈（Traceback）以及我们如何自定义异常并抛出异常。最后介绍了 `try` 语句.用一个函数的例子说明了，`try` 语句应该使用在对普遍函数进行特化的特殊函数当中，而非普遍函数中。

```python
def reduce(f, s, initial):
    """Combine elements of s using f starting with initial.

    >>> reduce(mul, [2, 4, 8], 1)
    64
    >>> reduce(add, [1, 2, 3, 4], 0)
    10
    """
    for x in s:
        initial = f(initial, x)
    return initial


def divide_all(n, ds):
    try:
        return reduce(truediv, ds, n)
    except ZeroDivisionError:
        return float('inf')
```

## Lecture 3

这节课补充上一节课的列表相关的内容，并实现了树这一数据结构。

首先补充的是列表的盒子-指针模型，列表的每个位置都是相当于一个名字，可以指向某个对象，甚至可以指向列表自身。接着补充了列表的切片。最后补充了一些应用到可迭代对象上面的聚合函数，例如 `sum`、`max`、`all`。

这节课实现的树特别地简洁，却和此前 C++ 中实现的树功能相同，再次被惊艳到了。再一次用函数和列表做了数据抽象，建立起了抽象屏障。看到这里，在思考 python 和其他语言中的 `class` 是否只是方便实现 OOP 的语法糖，因为这里完全不用 `class` 就做到了面向对象。这节课还介绍了在树上（用树递归）做一些统计，最后阐述了如何打印出一棵树（先根遍历和后根遍历）。

## Lecture 4

这节课的主题是可变和不可变对象这个概念，并介绍了元组。列表是一种可变对象，而元组是不可变对象。可变对象上有一些可变操作，这意味着，执行某个函数的时候，函数当中可能把自己之前绑定的可变对象给改变了。讲座中用列表作为默认参数的例子来阐述了这一点。与之相对的是不可变对象，一个不可变对象可以放心得放在代码中，不用担心调用了某个函数，做了一些意想不到的改变。但是，这种保护也有限的，因为函数里面有可能直接改变外部的名字绑定，让原来的名字指向新的对象。

```python
li, tu = [], ()
def foo():
    li.append('Something')
foo() # li has been changed, but tu has not.

def bar():
    nonlocal tu
    tu = 0
bar() # tu can be rebind to another object.
```

## Book ch 2.4 阅读笔记

Book ch 2.3 当中实现了一个 List，但是那个 List 并不是 mutable 的，这个章节用 dispatch 函数和 dispatch 字典实现了 mutable List。最后，介绍了消息传递（面向对象）用来对约束系统的建模。

